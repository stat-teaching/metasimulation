{
  "hash": "08669d19d6790e97f1fa649b00ad1bde",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Monte Carlo Simulations\nsubtitle: CSA 2024\n---\n\n\n\n\n# Monte Carlo Simulations (MCS) {.section}\n\n## Monte Carlo Simulations (MCS)\n\nsomething here\n\n# Why MCS are useful? {.section}\n\n## Why MCS are useful?\n\n**while(TRUE){**\n\n![](img/learningbysim.svg)\n\n**}**\n\n## A quick example, Welch t-test^[http://daniellakens.blogspot.com/2015/01/always-use-welchs-t-test-instead-of.html]\n\nWe are learning the t-test, and we read that if the two sample comes from populations with the same variance, we can use the regular t-test otherwise we should use the so-called Welch t-test.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](monte-carlo-simulations_files/figure-revealjs/unnamed-chunk-2-1.svg){fig-align='center' width=70%}\n:::\n:::\n\n\n## Cool! but why?\n\nWithout looking at the formula, let's simply try to simulate a t-test where we know the two populations have different variance and also simulate different sample size between the two groups:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnsim <- 1e4\n\nn0 <- 30\nn1 <- 20\nm0 <- 0\nm1 <- 0\nsratio <- 3\n\nequal_t <- vector(mode = \"list\", length = nsim)\nunequal_t <- vector(mode = \"list\", length = nsim)\n\nfor(i in 1:nsim){\n  g0 <- rnorm(n0, m0, 1)  \n  g1 <- rnorm(n1, m0, sratio)\n  equal_t[[i]] <- t.test(g0, g1, var.equal = TRUE)\n  unequal_t[[i]] <- t.test(g0, g1, var.equal = FALSE)\n}\n```\n:::\n\n\n## Cool! but why?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np_equal <- sapply(equal_t, function(x) x$p.value)\np_unequal <- sapply(unequal_t, function(x) x$p.value)\n\nmean(p_equal <= 0.05)\nmean(p_unequal <= 0.05)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0975\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0476\n```\n\n\n:::\n:::\n\n\nThe probability of making type-1 error is almost two times higher when using the standard t test\n\n## Cool! but why?\n\nLet's have a better look at the simulation results. We find the answer! The standard error is systematically lower using the standard t-test thus increasing the t value and the number of low p-values inflating the type-1 error rate.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](monte-carlo-simulations_files/figure-revealjs/unnamed-chunk-6-1.svg){fig-align='center' width=1248}\n:::\n:::\n\n\n## Cool! but why?^[Also the degrees of freedom calculation is different between the two approaches]\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n**Standard t-test**\n\n$$t = \\frac{\\bar{X_1} - \\bar{X_2}}{s_p\\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}}$$\n$$s_p = \\sqrt{\\frac{(n_1 - 1)s_1^2 + (n_2 - 1)s_2^2}{n_1 + n_2 - 2}}$$\n:::\n\n::: {.column width=\"50%\"}\n**Welch's t-test**\n\n$$t = \\frac{\\bar{X_1} - \\bar{X_2}}{\\sqrt{SE^2_{\\bar X_1} + SE^2_{\\bar X_2}}}$$\n$$SE_{X_i} = \\frac{s_i}{\\sqrt{n_i}}$$\n:::\n\n::::\n\n# General MCS strategy {.section}\n\n## General MCS strategy\n\nIn general, the following workflow can be useful when preparing a simulation:\n\n1. Define the data-generation process usually starting from the model equation\n2. Find the fixed parameters e.g., mean of group 1, etc.\n3. Find the R functions to generate data given 1 and 2\n4. Repeat the simulation several times\n5. Check the recovery of simulated parameters\n6. Compute the metrics that are useful for the simulation e.g., power, type1 error, etc.",
    "supporting": [
      "monte-carlo-simulations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}